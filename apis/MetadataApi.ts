/* tslint:disable */
/* eslint-disable */
/**
 * 
 * #### Enso API - Find detailed documentation on [docs.enso.finance](https://docs.enso.finance). - To use the API, **you must include your API Key in the Authorization header** (Bearer format). - For testing, Swagger pre-authorizes you using the key: `1e02632d-6feb-4a75-a157-documentation` (1rps). - Get your own API Key at [enso.finance/developers](https://enso.finance/developers).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ConnectedNetwork,
  NonTokenizedControllerTokens200Response,
  Price,
  ProtocolModel,
  TokensControllerTokens200Response,
} from '../models/index';
import {
    ConnectedNetworkFromJSON,
    ConnectedNetworkToJSON,
    NonTokenizedControllerTokens200ResponseFromJSON,
    NonTokenizedControllerTokens200ResponseToJSON,
    PriceFromJSON,
    PriceToJSON,
    ProtocolModelFromJSON,
    ProtocolModelToJSON,
    TokensControllerTokens200ResponseFromJSON,
    TokensControllerTokens200ResponseToJSON,
} from '../models/index';

export interface NetworksControllerNetworksRequest {
    name?: any;
    chainId?: any;
}

export interface NonTokenizedControllerTokensRequest {
    project?: string;
    protocolSlug?: string;
    chainId?: number;
    address?: Array<string>;
    primaryAddress?: Array<string>;
    page?: number;
    cursor?: number;
}

export interface PricesControllerGetPriceRequest {
    address: any;
    chainId: any;
}

export interface PricesControllerGetPricesRequest {
    chainId: number;
    addresses: Array<string>;
}

export interface ProtocolsControllerFindAllRequest {
    chainId?: any;
    slug?: any;
}

export interface TokensControllerTokensRequest {
    project?: string;
    protocolSlug?: string;
    underlyingTokens?: Array<string>;
    underlyingTokensExact?: Array<string>;
    primaryAddress?: Array<string>;
    address?: Array<string>;
    name?: Array<string>;
    symbol?: Array<string>;
    chainId?: number;
    type?: TokensControllerTokensTypeEnum;
    page?: number;
    cursor?: number;
    includeMetadata?: boolean;
    apyFrom?: number;
    apyTo?: number;
    tvlFrom?: number;
    tvlTo?: number;
}

export interface VolumeControllerGetVolumeRequest {
    chainId: number;
}

/**
 * 
 */
export class MetadataApi extends runtime.BaseAPI {

    /**
     * Returns aggregators supported by the API (can be controled via disableAggregators param)
     */
    async aggregatorsControllerAggregatorsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/aggregators`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns aggregators supported by the API (can be controled via disableAggregators param)
     */
    async aggregatorsControllerAggregators(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.aggregatorsControllerAggregatorsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns networks supported by the API
     */
    async networksControllerNetworksRaw(requestParameters: NetworksControllerNetworksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ConnectedNetwork>>> {
        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['chainId'] != null) {
            queryParameters['chainId'] = requestParameters['chainId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/networks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ConnectedNetworkFromJSON));
    }

    /**
     * Returns networks supported by the API
     */
    async networksControllerNetworks(requestParameters: NetworksControllerNetworksRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ConnectedNetwork>> {
        const response = await this.networksControllerNetworksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns nontokenized positions and their details
     */
    async nonTokenizedControllerTokensRaw(requestParameters: NonTokenizedControllerTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NonTokenizedControllerTokens200Response>> {
        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['protocolSlug'] != null) {
            queryParameters['protocolSlug'] = requestParameters['protocolSlug'];
        }

        if (requestParameters['chainId'] != null) {
            queryParameters['chainId'] = requestParameters['chainId'];
        }

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        if (requestParameters['primaryAddress'] != null) {
            queryParameters['primaryAddress'] = requestParameters['primaryAddress'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/nontokenized`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NonTokenizedControllerTokens200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns nontokenized positions and their details
     */
    async nonTokenizedControllerTokens(requestParameters: NonTokenizedControllerTokensRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NonTokenizedControllerTokens200Response> {
        const response = await this.nonTokenizedControllerTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns price for a token
     */
    async pricesControllerGetPriceRaw(requestParameters: PricesControllerGetPriceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Price>> {
        if (requestParameters['address'] == null) {
            throw new runtime.RequiredError(
                'address',
                'Required parameter "address" was null or undefined when calling pricesControllerGetPrice().'
            );
        }

        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling pricesControllerGetPrice().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/prices/{chainId}/{address}`.replace(`{${"address"}}`, encodeURIComponent(String(requestParameters['address']))).replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PriceFromJSON(jsonValue));
    }

    /**
     * Returns price for a token
     */
    async pricesControllerGetPrice(requestParameters: PricesControllerGetPriceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Price> {
        const response = await this.pricesControllerGetPriceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns price for multiple tokens
     */
    async pricesControllerGetPricesRaw(requestParameters: PricesControllerGetPricesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Price>>> {
        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling pricesControllerGetPrices().'
            );
        }

        if (requestParameters['addresses'] == null) {
            throw new runtime.RequiredError(
                'addresses',
                'Required parameter "addresses" was null or undefined when calling pricesControllerGetPrices().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['addresses'] != null) {
            queryParameters['addresses'] = requestParameters['addresses'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/prices/{chainId}`.replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PriceFromJSON));
    }

    /**
     * Returns price for multiple tokens
     */
    async pricesControllerGetPrices(requestParameters: PricesControllerGetPricesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Price>> {
        const response = await this.pricesControllerGetPricesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns projects and relevant protocols available to use
     */
    async protocolsControllerFindAllRaw(requestParameters: ProtocolsControllerFindAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ProtocolModel>>> {
        const queryParameters: any = {};

        if (requestParameters['chainId'] != null) {
            queryParameters['chainId'] = requestParameters['chainId'];
        }

        if (requestParameters['slug'] != null) {
            queryParameters['slug'] = requestParameters['slug'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/protocols`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ProtocolModelFromJSON));
    }

    /**
     * Returns projects and relevant protocols available to use
     */
    async protocolsControllerFindAll(requestParameters: ProtocolsControllerFindAllRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ProtocolModel>> {
        const response = await this.protocolsControllerFindAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns tokens and their details
     */
    async tokensControllerTokensRaw(requestParameters: TokensControllerTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokensControllerTokens200Response>> {
        const queryParameters: any = {};

        if (requestParameters['project'] != null) {
            queryParameters['project'] = requestParameters['project'];
        }

        if (requestParameters['protocolSlug'] != null) {
            queryParameters['protocolSlug'] = requestParameters['protocolSlug'];
        }

        if (requestParameters['underlyingTokens'] != null) {
            queryParameters['underlyingTokens'] = requestParameters['underlyingTokens'];
        }

        if (requestParameters['underlyingTokensExact'] != null) {
            queryParameters['underlyingTokensExact'] = requestParameters['underlyingTokensExact'];
        }

        if (requestParameters['primaryAddress'] != null) {
            queryParameters['primaryAddress'] = requestParameters['primaryAddress'];
        }

        if (requestParameters['address'] != null) {
            queryParameters['address'] = requestParameters['address'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['symbol'] != null) {
            queryParameters['symbol'] = requestParameters['symbol'];
        }

        if (requestParameters['chainId'] != null) {
            queryParameters['chainId'] = requestParameters['chainId'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['includeMetadata'] != null) {
            queryParameters['includeMetadata'] = requestParameters['includeMetadata'];
        }

        if (requestParameters['apyFrom'] != null) {
            queryParameters['apyFrom'] = requestParameters['apyFrom'];
        }

        if (requestParameters['apyTo'] != null) {
            queryParameters['apyTo'] = requestParameters['apyTo'];
        }

        if (requestParameters['tvlFrom'] != null) {
            queryParameters['tvlFrom'] = requestParameters['tvlFrom'];
        }

        if (requestParameters['tvlTo'] != null) {
            queryParameters['tvlTo'] = requestParameters['tvlTo'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/tokens`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokensControllerTokens200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns tokens and their details
     */
    async tokensControllerTokens(requestParameters: TokensControllerTokensRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokensControllerTokens200Response> {
        const response = await this.tokensControllerTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns chain USD volume and total transactions
     */
    async volumeControllerGetVolumeRaw(requestParameters: VolumeControllerGetVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling volumeControllerGetVolume().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/volume/{chainId}`.replace(`{${"chainId"}}`, encodeURIComponent(String(requestParameters['chainId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns chain USD volume and total transactions
     */
    async volumeControllerGetVolume(requestParameters: VolumeControllerGetVolumeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.volumeControllerGetVolumeRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const TokensControllerTokensTypeEnum = {
    Defi: 'defi',
    Base: 'base'
} as const;
export type TokensControllerTokensTypeEnum = typeof TokensControllerTokensTypeEnum[keyof typeof TokensControllerTokensTypeEnum];
