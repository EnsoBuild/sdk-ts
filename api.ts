/* tslint:disable */
/* eslint-disable */
/**
 * 
 * #### Enso API - Find detailed documentation on [docs.enso.finance](https://docs.enso.finance). - To use the API, **you must include your API Key in the Authorization header** (Bearer format). - For testing, Swagger pre-authorizes you using the key: `1e02632d-6feb-4a75-a157-documentation` (1rps). - Get your own API Key at [enso.finance/developers](https://enso.finance/developers).
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'action': ActionActionEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Action
     */
    'inputs': { [key: string]: string; };
}

export const ActionActionEnum = {
    Approve: 'approve',
    Borrow: 'borrow',
    Bridge: 'bridge',
    Deposit: 'deposit',
    Singledeposit: 'singledeposit',
    Multideposit: 'multideposit',
    Tokenizedsingledeposit: 'tokenizedsingledeposit',
    Tokenizedmultideposit: 'tokenizedmultideposit',
    Multioutsingledeposit: 'multioutsingledeposit',
    Depositclmm: 'depositclmm',
    Harvest: 'harvest',
    Permittransferfrom: 'permittransferfrom',
    Redeem: 'redeem',
    Singleredeem: 'singleredeem',
    Multiredeem: 'multiredeem',
    Tokenizedsingleredeem: 'tokenizedsingleredeem',
    Tokenizedmultiredeem: 'tokenizedmultiredeem',
    Redeemclmm: 'redeemclmm',
    Repay: 'repay',
    Swap: 'swap',
    Transfer: 'transfer',
    Transferfrom: 'transferfrom',
    Route: 'route',
    Call: 'call',
    Split: 'split',
    Merge: 'merge',
    Balance: 'balance',
    Minamountout: 'minamountout',
    Slippage: 'slippage',
    Fee: 'fee',
    Ensofee: 'ensofee'
} as const;

export type ActionActionEnum = typeof ActionActionEnum[keyof typeof ActionActionEnum];

/**
 * 
 * @export
 * @interface ActionToBundle
 */
export interface ActionToBundle {
    /**
     * Protocol to interact with
     * @type {string}
     * @memberof ActionToBundle
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof ActionToBundle
     */
    'action': ActionToBundleActionEnum;
    /**
     * 
     * @type {object}
     * @memberof ActionToBundle
     */
    'args': object;
}

export const ActionToBundleActionEnum = {
    Approve: 'approve',
    Borrow: 'borrow',
    Bridge: 'bridge',
    Deposit: 'deposit',
    Singledeposit: 'singledeposit',
    Multideposit: 'multideposit',
    Tokenizedsingledeposit: 'tokenizedsingledeposit',
    Tokenizedmultideposit: 'tokenizedmultideposit',
    Multioutsingledeposit: 'multioutsingledeposit',
    Depositclmm: 'depositclmm',
    Harvest: 'harvest',
    Permittransferfrom: 'permittransferfrom',
    Redeem: 'redeem',
    Singleredeem: 'singleredeem',
    Multiredeem: 'multiredeem',
    Tokenizedsingleredeem: 'tokenizedsingleredeem',
    Tokenizedmultiredeem: 'tokenizedmultiredeem',
    Redeemclmm: 'redeemclmm',
    Repay: 'repay',
    Swap: 'swap',
    Transfer: 'transfer',
    Transferfrom: 'transferfrom',
    Route: 'route',
    Call: 'call',
    Split: 'split',
    Merge: 'merge',
    Balance: 'balance',
    Minamountout: 'minamountout',
    Slippage: 'slippage',
    Fee: 'fee',
    Ensofee: 'ensofee'
} as const;

export type ActionToBundleActionEnum = typeof ActionToBundleActionEnum[keyof typeof ActionToBundleActionEnum];

/**
 * 
 * @export
 * @interface BundleShortcutTransaction
 */
export interface BundleShortcutTransaction {
    /**
     * 
     * @type {Array<ActionToBundle>}
     * @memberof BundleShortcutTransaction
     */
    'bundle': Array<ActionToBundle>;
    /**
     * 
     * @type {string}
     * @memberof BundleShortcutTransaction
     */
    'gas': string;
    /**
     * 
     * @type {object}
     * @memberof BundleShortcutTransaction
     */
    'amountsOut': object;
    /**
     * The route the shortcut will use
     * @type {Array<Hop>}
     * @memberof BundleShortcutTransaction
     */
    'route'?: Array<Hop>;
    /**
     * Block number the transaction was created on
     * @type {number}
     * @memberof BundleShortcutTransaction
     */
    'createdAt': number;
    /**
     * The tx object to use in `ethers`
     * @type {Transaction}
     * @memberof BundleShortcutTransaction
     */
    'tx': Transaction;
}
/**
 * 
 * @export
 * @interface ConnectedNetwork
 */
export interface ConnectedNetwork {
    /**
     * 
     * @type {number}
     * @memberof ConnectedNetwork
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ConnectedNetwork
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectedNetwork
     */
    'isConnected': boolean;
}
/**
 * 
 * @export
 * @interface Hop
 */
export interface Hop {
    /**
     * 
     * @type {Array<string>}
     * @memberof Hop
     */
    'tokenIn': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Hop
     */
    'tokenOut': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Hop
     */
    'protocol': string;
    /**
     * 
     * @type {string}
     * @memberof Hop
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof Hop
     */
    'primary': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Hop
     */
    'internalRoutes': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof Hop
     */
    'args': object;
    /**
     * 
     * @type {number}
     * @memberof Hop
     */
    'chainId'?: number;
}
/**
 * 
 * @export
 * @interface IporShortcutInput
 */
export interface IporShortcutInput {
    /**
     * Flag that indicates whether to use the shared router
     * @type {boolean}
     * @memberof IporShortcutInput
     */
    'isRouter'?: boolean | null;
    /**
     * Amount of tokenIn in wei
     * @type {string}
     * @memberof IporShortcutInput
     */
    'amountIn': string;
    /**
     * Address of the tokenIn. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
     * @type {string}
     * @memberof IporShortcutInput
     */
    'tokenIn': string;
    /**
     * Address of the tokenBToBuy
     * @type {string}
     * @memberof IporShortcutInput
     */
    'tokenBToBuy': string;
    /**
     * Percentage of tokenB to buy in basis points (1/10000)
     * @type {string}
     * @memberof IporShortcutInput
     */
    'percentageForTokenB': string;
    /**
     * Slippage in basis points (1/10000). Default is 300
     * @type {string}
     * @memberof IporShortcutInput
     */
    'slippage'?: string;
    /**
     * Flag that indicates whether to simulate the transaction, verify some assertions, return simulationURL and events
     * @type {boolean}
     * @memberof IporShortcutInput
     */
    'simulate'?: boolean | null;
}
/**
 * 
 * @export
 * @interface IporShortcutTransaction
 */
export interface IporShortcutTransaction {
    /**
     * Block number the transaction was created on
     * @type {number}
     * @memberof IporShortcutTransaction
     */
    'createdAt': number;
    /**
     * The tx object to use in `ethers`
     * @type {Transaction}
     * @memberof IporShortcutTransaction
     */
    'tx': Transaction;
    /**
     * Logs from the simulated transaction
     * @type {Array<string>}
     * @memberof IporShortcutTransaction
     */
    'logs': Array<string>;
    /**
     * Tenderly simulation URL
     * @type {string}
     * @memberof IporShortcutTransaction
     */
    'simulationURL': string;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {number}
     * @memberof Network
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface NonTokenizedControllerTokens200Response
 */
export interface NonTokenizedControllerTokens200Response {
    /**
     * Metadata for pagination
     * @type {PaginationMeta}
     * @memberof NonTokenizedControllerTokens200Response
     */
    'meta': PaginationMeta;
    /**
     * Returned data for current page
     * @type {Array<NonTokenizedModel>}
     * @memberof NonTokenizedControllerTokens200Response
     */
    'data'?: Array<NonTokenizedModel>;
}
/**
 * 
 * @export
 * @interface NonTokenizedModel
 */
export interface NonTokenizedModel {
    /**
     * Chain ID of the network of the nontokenized position
     * @type {number}
     * @memberof NonTokenizedModel
     */
    'chainId': number;
    /**
     * The specific standard integration or version of the nontokenized position
     * @type {string}
     * @memberof NonTokenizedModel
     */
    'protocol': string;
    /**
     * Ethereum address of the nontokenized position
     * @type {string}
     * @memberof NonTokenizedModel
     */
    'address': string;
    /**
     * Ethereum address of the nontokenized position
     * @type {string}
     * @memberof NonTokenizedModel
     */
    'primaryAddress': string;
    /**
     * Underlying tokens of nontokenized position
     * @type {Array<TokenModel>}
     * @memberof NonTokenizedModel
     */
    'underlyingTokens': Array<TokenModel> | null;
}
/**
 * 
 * @export
 * @interface PaginatedResult
 */
export interface PaginatedResult {
    /**
     * Metadata for pagination
     * @type {PaginationMeta}
     * @memberof PaginatedResult
     */
    'meta': PaginationMeta;
}
/**
 * 
 * @export
 * @interface PaginationMeta
 */
export interface PaginationMeta {
    /**
     * Total amount of pages
     * @type {number}
     * @memberof PaginationMeta
     */
    'total': number;
    /**
     * Last page number
     * @type {number}
     * @memberof PaginationMeta
     */
    'lastPage': number;
    /**
     * Current page number
     * @type {number}
     * @memberof PaginationMeta
     */
    'currentPage': number;
    /**
     * Amount of elements per page
     * @type {number}
     * @memberof PaginationMeta
     */
    'perPage': number;
    /**
     * Previous page
     * @type {number}
     * @memberof PaginationMeta
     */
    'prev': number;
    /**
     * Next page
     * @type {number}
     * @memberof PaginationMeta
     */
    'next': number;
    /**
     * Cursor for pagination
     * @type {number}
     * @memberof PaginationMeta
     */
    'cursor': number;
}
/**
 * 
 * @export
 * @interface PositionModel
 */
export interface PositionModel {
    /**
     * Ethereum address of the token
     * @type {string}
     * @memberof PositionModel
     */
    'address': string;
    /**
     * Chain ID of the network of the token
     * @type {number}
     * @memberof PositionModel
     */
    'chainId': number;
    /**
     * Type of token
     * @type {string}
     * @memberof PositionModel
     */
    'type': string;
    /**
     * Token decimals
     * @type {number}
     * @memberof PositionModel
     */
    'decimals': number;
    /**
     * Token name
     * @type {string}
     * @memberof PositionModel
     */
    'symbol': string | null;
    /**
     * Token symbol
     * @type {string}
     * @memberof PositionModel
     */
    'name': string | null;
    /**
     * A list of logos for the token
     * @type {Array<string>}
     * @memberof PositionModel
     */
    'logosUri': Array<string> | null;
    /**
     * Underlying tokens of defi token
     * @type {Array<TokenModel>}
     * @memberof PositionModel
     */
    'underlyingTokens': Array<TokenModel> | null;
    /**
     * The overarching project or platform associated with the DeFi token
     * @type {string}
     * @memberof PositionModel
     */
    'project': string | null;
    /**
     * The specific standard integration or version of the DeFi project
     * @type {string}
     * @memberof PositionModel
     */
    'protocolSlug': string | null;
    /**
     * The defi position APY
     * @type {number}
     * @memberof PositionModel
     */
    'apy': number | null;
    /**
     * The defi position base APY
     * @type {number}
     * @memberof PositionModel
     */
    'apyBase': number | null;
    /**
     * The defi position reward APY
     * @type {number}
     * @memberof PositionModel
     */
    'apyReward': number | null;
    /**
     * The defi position TVL
     * @type {number}
     * @memberof PositionModel
     */
    'tvl': number | null;
    /**
     * Ethereum address for contract interaction of defi token
     * @type {string}
     * @memberof PositionModel
     */
    'primaryAddress': string | null;
}
/**
 * 
 * @export
 * @interface Price
 */
export interface Price {
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'decimals': number;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Price
     */
    'symbol': string;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'timestamp': number;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'chainId': number;
    /**
     * 
     * @type {number}
     * @memberof Price
     */
    'confidence': number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Project
     */
    'chains': Array<string>;
}
/**
 * 
 * @export
 * @interface Protocol
 */
export interface Protocol {
    /**
     * 
     * @type {string}
     * @memberof Protocol
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof Protocol
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ProtocolModel
 */
export interface ProtocolModel {
    /**
     * 
     * @type {string}
     * @memberof ProtocolModel
     */
    'project': string;
    /**
     * 
     * @type {string}
     * @memberof ProtocolModel
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof ProtocolModel
     */
    'name': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProtocolModel
     */
    'description': string | null;
    /**
     * 
     * @type {string}
     * @memberof ProtocolModel
     */
    'url': string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProtocolModel
     */
    'logosUri': Array<string> | null;
    /**
     * 
     * @type {Array<Network>}
     * @memberof ProtocolModel
     */
    'chains': Array<Network> | null;
}
/**
 * 
 * @export
 * @interface RouteShortcutTransaction
 */
export interface RouteShortcutTransaction {
    /**
     * 
     * @type {string}
     * @memberof RouteShortcutTransaction
     */
    'gas': string;
    /**
     * 
     * @type {string}
     * @memberof RouteShortcutTransaction
     */
    'amountOut': string;
    /**
     * Price impact in basis points, null if USD price not found
     * @type {number}
     * @memberof RouteShortcutTransaction
     */
    'priceImpact': number;
    /**
     * An array of the fee amount collected for each tokenIn
     * @type {Array<string>}
     * @memberof RouteShortcutTransaction
     */
    'feeAmount': Array<string>;
    /**
     * Block number the transaction was created on
     * @type {number}
     * @memberof RouteShortcutTransaction
     */
    'createdAt': number;
    /**
     * The tx object to use in `ethers`
     * @type {Transaction}
     * @memberof RouteShortcutTransaction
     */
    'tx': Transaction;
    /**
     * The route the shortcut will use
     * @type {Array<Hop>}
     * @memberof RouteShortcutTransaction
     */
    'route': Array<Hop>;
}
/**
 * 
 * @export
 * @interface RouteShortcutVariableInputs
 */
export interface RouteShortcutVariableInputs {
    /**
     * Chain ID of the network to execute the transaction on
     * @type {number}
     * @memberof RouteShortcutVariableInputs
     */
    'chainId'?: number;
    /**
     * Ethereum address of the wallet to send the transaction from
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'fromAddress': string;
    /**
     * Routing strategy to use
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'routingStrategy'?: RouteShortcutVariableInputsRoutingStrategyEnum | null;
    /**
     * Flag that indicates if gained tokenOut should be sent to EOA
     * @type {boolean}
     * @memberof RouteShortcutVariableInputs
     * @deprecated
     */
    'toEoa'?: boolean | null;
    /**
     * Ethereum address of the receiver of the tokenOut
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'receiver'?: string;
    /**
     * Ethereum address of the spender of the tokenIn
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'spender'?: string;
    /**
     * Amount of tokenIn to swap in wei
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'amountIn': Array<string>;
    /**
     * Minimum amount out in wei. If specified, slippage should not be specified
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'minAmountOut'?: Array<string>;
    /**
     * Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'slippage'?: string;
    /**
     * Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'fee'?: Array<string>;
    /**
     * The Ethereum address that will receive the collected fee. Required if fee is provided
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'feeReceiver'?: string;
    /**
     * A list of swap aggregators to be ignored from consideration
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'ignoreAggregators'?: Array<string> | null;
    /**
     * A list of standards to be ignored from consideration
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'ignoreStandards'?: Array<string> | null;
    /**
     * Referral code that will be included in an on-chain event.
     * @type {string}
     * @memberof RouteShortcutVariableInputs
     */
    'referralCode'?: string;
    /**
     * Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'tokenIn': Array<string>;
    /**
     * Ethereum address of the token to swap to. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
     * @type {Array<string>}
     * @memberof RouteShortcutVariableInputs
     */
    'tokenOut': Array<string>;
    /**
     * Chain ID of the network to bridge to and receive tokenOut
     * @type {number}
     * @memberof RouteShortcutVariableInputs
     */
    'destinationChainId'?: number;
    /**
     * 
     * @type {object}
     * @memberof RouteShortcutVariableInputs
     */
    'variableEstimates': object;
}

export const RouteShortcutVariableInputsRoutingStrategyEnum = {
    Ensowallet: 'ensowallet',
    Router: 'router',
    Delegate: 'delegate',
    RouterLegacy: 'router-legacy',
    DelegateLegacy: 'delegate-legacy'
} as const;

export type RouteShortcutVariableInputsRoutingStrategyEnum = typeof RouteShortcutVariableInputsRoutingStrategyEnum[keyof typeof RouteShortcutVariableInputsRoutingStrategyEnum];

/**
 * 
 * @export
 * @interface Standard
 */
export interface Standard {
    /**
     * 
     * @type {Protocol}
     * @memberof Standard
     */
    'protocol': Protocol;
    /**
     * 
     * @type {Array<Protocol>}
     * @memberof Standard
     */
    'forks': Array<Protocol>;
    /**
     * 
     * @type {Array<StandardAction>}
     * @memberof Standard
     */
    'actions': Array<StandardAction>;
}
/**
 * 
 * @export
 * @interface StandardAction
 */
export interface StandardAction {
    /**
     * 
     * @type {string}
     * @memberof StandardAction
     */
    'action': StandardActionActionEnum;
    /**
     * 
     * @type {string}
     * @memberof StandardAction
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StandardAction
     */
    'functionNames': Array<string>;
    /**
     * 
     * @type {Array<Network>}
     * @memberof StandardAction
     */
    'supportedChains': Array<Network>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StandardAction
     */
    'inputs': Array<string>;
}

export const StandardActionActionEnum = {
    Approve: 'approve',
    Borrow: 'borrow',
    Bridge: 'bridge',
    Deposit: 'deposit',
    Singledeposit: 'singledeposit',
    Multideposit: 'multideposit',
    Tokenizedsingledeposit: 'tokenizedsingledeposit',
    Tokenizedmultideposit: 'tokenizedmultideposit',
    Multioutsingledeposit: 'multioutsingledeposit',
    Depositclmm: 'depositclmm',
    Harvest: 'harvest',
    Permittransferfrom: 'permittransferfrom',
    Redeem: 'redeem',
    Singleredeem: 'singleredeem',
    Multiredeem: 'multiredeem',
    Tokenizedsingleredeem: 'tokenizedsingleredeem',
    Tokenizedmultiredeem: 'tokenizedmultiredeem',
    Redeemclmm: 'redeemclmm',
    Repay: 'repay',
    Swap: 'swap',
    Transfer: 'transfer',
    Transferfrom: 'transferfrom',
    Route: 'route',
    Call: 'call',
    Split: 'split',
    Merge: 'merge',
    Balance: 'balance',
    Minamountout: 'minamountout',
    Slippage: 'slippage',
    Fee: 'fee',
    Ensofee: 'ensofee'
} as const;

export type StandardActionActionEnum = typeof StandardActionActionEnum[keyof typeof StandardActionActionEnum];

/**
 * 
 * @export
 * @interface TokenModel
 */
export interface TokenModel {
    /**
     * Ethereum address of the token
     * @type {string}
     * @memberof TokenModel
     */
    'address': string;
    /**
     * Chain ID of the network of the token
     * @type {number}
     * @memberof TokenModel
     */
    'chainId': number;
    /**
     * Type of token
     * @type {string}
     * @memberof TokenModel
     */
    'type': string;
    /**
     * Token decimals
     * @type {number}
     * @memberof TokenModel
     */
    'decimals': number;
    /**
     * Token name
     * @type {string}
     * @memberof TokenModel
     */
    'symbol': string | null;
    /**
     * Token symbol
     * @type {string}
     * @memberof TokenModel
     */
    'name': string | null;
    /**
     * A list of logos for the token
     * @type {Array<string>}
     * @memberof TokenModel
     */
    'logosUri': Array<string> | null;
}
/**
 * 
 * @export
 * @interface TokensControllerTokens200Response
 */
export interface TokensControllerTokens200Response {
    /**
     * Metadata for pagination
     * @type {PaginationMeta}
     * @memberof TokensControllerTokens200Response
     */
    'meta': PaginationMeta;
    /**
     * Returned data for current page
     * @type {Array<PositionModel>}
     * @memberof TokensControllerTokens200Response
     */
    'data'?: Array<PositionModel>;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface WalletApproveTransaction
 */
export interface WalletApproveTransaction {
    /**
     * The tx object to use in `ethers`
     * @type {object}
     * @memberof WalletApproveTransaction
     */
    'tx': object;
    /**
     * The gas estimate for the transaction
     * @type {string}
     * @memberof WalletApproveTransaction
     */
    'gas': string;
    /**
     * The token address to approve
     * @type {string}
     * @memberof WalletApproveTransaction
     */
    'token': string;
    /**
     * The amount of tokens to approve
     * @type {string}
     * @memberof WalletApproveTransaction
     */
    'amount': string;
    /**
     * The spender address to approve
     * @type {string}
     * @memberof WalletApproveTransaction
     */
    'spender': string;
}
/**
 * 
 * @export
 * @interface WalletBalance
 */
export interface WalletBalance {
    /**
     * The address of the token
     * @type {string}
     * @memberof WalletBalance
     */
    'token': string;
    /**
     * The unformatted balance of the token
     * @type {string}
     * @memberof WalletBalance
     */
    'amount': string;
    /**
     * The unformatted balance of the token
     * @type {number}
     * @memberof WalletBalance
     */
    'decimals': number;
    /**
     * Price of the token in usd
     * @type {string}
     * @memberof WalletBalance
     */
    'price': string;
    /**
     * Name of the token
     * @type {string}
     * @memberof WalletBalance
     */
    'name': string;
    /**
     * Symbol of the token
     * @type {string}
     * @memberof WalletBalance
     */
    'symbol': string;
    /**
     * Logo of the token
     * @type {string}
     * @memberof WalletBalance
     */
    'logoUri': string;
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns aggregators supported by the API (can be controled via disableAggregators param)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorsControllerAggregators: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/aggregators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns networks supported by the API
         * @param {any} [name] Title of the network to search for
         * @param {any} [chainId] Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksControllerNetworks: async (name?: any, chainId?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                for (const [key, value] of Object.entries(name)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (chainId !== undefined) {
                for (const [key, value] of Object.entries(chainId)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns nontokenized positions and their details
         * @param {string} [project] The overarching project or platform associated with the DeFi token
         * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
         * @param {number} [chainId] Chain ID of the network of the nontokenized position
         * @param {Array<string>} [address] Ethereum addresses of the nontokenized positions
         * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of nontokenized position
         * @param {number} [page] Pagination page number. Pages are of length 1000
         * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonTokenizedControllerTokens: async (project?: string, protocolSlug?: string, chainId?: number, address?: Array<string>, primaryAddress?: Array<string>, page?: number, cursor?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/nontokenized`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (protocolSlug !== undefined) {
                localVarQueryParameter['protocolSlug'] = protocolSlug;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (address) {
                localVarQueryParameter['address'] = address;
            }

            if (primaryAddress) {
                localVarQueryParameter['primaryAddress'] = primaryAddress;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns price for a token
         * @param {any} address Address of the token to search for
         * @param {any} chainId Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesControllerGetPrice: async (address: any, chainId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('pricesControllerGetPrice', 'address', address)
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('pricesControllerGetPrice', 'chainId', chainId)
            const localVarPath = `/api/v1/prices/{chainId}/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"chainId"}}`, encodeURIComponent(String(chainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns price for multiple tokens
         * @param {number} chainId Chain ID of the network to search for
         * @param {Array<string>} addresses Ethereum address of the token to check price for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesControllerGetPrices: async (chainId: number, addresses: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('pricesControllerGetPrices', 'chainId', chainId)
            // verify required parameter 'addresses' is not null or undefined
            assertParamExists('pricesControllerGetPrices', 'addresses', addresses)
            const localVarPath = `/api/v1/prices/{chainId}`
                .replace(`{${"chainId"}}`, encodeURIComponent(String(chainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (addresses) {
                localVarQueryParameter['addresses'] = addresses;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns projects and relevant protocols available to use
         * @param {any} [chainId] Chain ID of the network to search for
         * @param {any} [slug] slug of the project to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protocolsControllerFindAll: async (chainId?: any, slug?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                for (const [key, value] of Object.entries(chainId)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (slug !== undefined) {
                for (const [key, value] of Object.entries(slug)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns tokens and their details
         * @param {string} [project] The overarching project or platform associated with the DeFi token
         * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
         * @param {Array<string>} [underlyingTokens] Underlying tokens of defi token
         * @param {Array<string>} [underlyingTokensExact] Exact composition of underlying tokens of defi token
         * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of defi tokens
         * @param {Array<string>} [address] Ethereum addresses of the tokens
         * @param {Array<string>} [name] Names of the tokens
         * @param {Array<string>} [symbol] Symbols of the tokens
         * @param {number} [chainId] Chain ID of the network of the token
         * @param {TokensControllerTokensTypeEnum} [type] Type of token.       If not provided, both types will be taken into account
         * @param {number} [page] Pagination page number. Pages are of length 1000
         * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
         * @param {boolean} [includeMetadata] Whether to include token metadata (symbol, name and logos)
         * @param {number} [apyFrom] Only include tokens with APY over this value
         * @param {number} [apyTo] Only include tokens with APY below this value
         * @param {number} [tvlFrom] Only include tokens with TVL over this value
         * @param {number} [tvlTo] Only include tokens with TVL below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensControllerTokens: async (project?: string, protocolSlug?: string, underlyingTokens?: Array<string>, underlyingTokensExact?: Array<string>, primaryAddress?: Array<string>, address?: Array<string>, name?: Array<string>, symbol?: Array<string>, chainId?: number, type?: TokensControllerTokensTypeEnum, page?: number, cursor?: number, includeMetadata?: boolean, apyFrom?: number, apyTo?: number, tvlFrom?: number, tvlTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (protocolSlug !== undefined) {
                localVarQueryParameter['protocolSlug'] = protocolSlug;
            }

            if (underlyingTokens) {
                localVarQueryParameter['underlyingTokens'] = underlyingTokens;
            }

            if (underlyingTokensExact) {
                localVarQueryParameter['underlyingTokensExact'] = underlyingTokensExact;
            }

            if (primaryAddress) {
                localVarQueryParameter['primaryAddress'] = primaryAddress;
            }

            if (address) {
                localVarQueryParameter['address'] = address;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (symbol) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['includeMetadata'] = includeMetadata;
            }

            if (apyFrom !== undefined) {
                localVarQueryParameter['apyFrom'] = apyFrom;
            }

            if (apyTo !== undefined) {
                localVarQueryParameter['apyTo'] = apyTo;
            }

            if (tvlFrom !== undefined) {
                localVarQueryParameter['tvlFrom'] = tvlFrom;
            }

            if (tvlTo !== undefined) {
                localVarQueryParameter['tvlTo'] = tvlTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns chain USD volume and total transactions
         * @param {number} chainId Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumeControllerGetVolume: async (chainId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chainId' is not null or undefined
            assertParamExists('volumeControllerGetVolume', 'chainId', chainId)
            const localVarPath = `/api/v1/volume/{chainId}`
                .replace(`{${"chainId"}}`, encodeURIComponent(String(chainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns aggregators supported by the API (can be controled via disableAggregators param)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregatorsControllerAggregators(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregatorsControllerAggregators(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.aggregatorsControllerAggregators']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns networks supported by the API
         * @param {any} [name] Title of the network to search for
         * @param {any} [chainId] Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksControllerNetworks(name?: any, chainId?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectedNetwork>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksControllerNetworks(name, chainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.networksControllerNetworks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns nontokenized positions and their details
         * @param {string} [project] The overarching project or platform associated with the DeFi token
         * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
         * @param {number} [chainId] Chain ID of the network of the nontokenized position
         * @param {Array<string>} [address] Ethereum addresses of the nontokenized positions
         * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of nontokenized position
         * @param {number} [page] Pagination page number. Pages are of length 1000
         * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nonTokenizedControllerTokens(project?: string, protocolSlug?: string, chainId?: number, address?: Array<string>, primaryAddress?: Array<string>, page?: number, cursor?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonTokenizedControllerTokens200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nonTokenizedControllerTokens(project, protocolSlug, chainId, address, primaryAddress, page, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.nonTokenizedControllerTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns price for a token
         * @param {any} address Address of the token to search for
         * @param {any} chainId Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesControllerGetPrice(address: any, chainId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Price>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesControllerGetPrice(address, chainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.pricesControllerGetPrice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns price for multiple tokens
         * @param {number} chainId Chain ID of the network to search for
         * @param {Array<string>} addresses Ethereum address of the token to check price for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricesControllerGetPrices(chainId: number, addresses: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Price>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pricesControllerGetPrices(chainId, addresses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.pricesControllerGetPrices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns projects and relevant protocols available to use
         * @param {any} [chainId] Chain ID of the network to search for
         * @param {any} [slug] slug of the project to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async protocolsControllerFindAll(chainId?: any, slug?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProtocolModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.protocolsControllerFindAll(chainId, slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.protocolsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns tokens and their details
         * @param {string} [project] The overarching project or platform associated with the DeFi token
         * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
         * @param {Array<string>} [underlyingTokens] Underlying tokens of defi token
         * @param {Array<string>} [underlyingTokensExact] Exact composition of underlying tokens of defi token
         * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of defi tokens
         * @param {Array<string>} [address] Ethereum addresses of the tokens
         * @param {Array<string>} [name] Names of the tokens
         * @param {Array<string>} [symbol] Symbols of the tokens
         * @param {number} [chainId] Chain ID of the network of the token
         * @param {TokensControllerTokensTypeEnum} [type] Type of token.       If not provided, both types will be taken into account
         * @param {number} [page] Pagination page number. Pages are of length 1000
         * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
         * @param {boolean} [includeMetadata] Whether to include token metadata (symbol, name and logos)
         * @param {number} [apyFrom] Only include tokens with APY over this value
         * @param {number} [apyTo] Only include tokens with APY below this value
         * @param {number} [tvlFrom] Only include tokens with TVL over this value
         * @param {number} [tvlTo] Only include tokens with TVL below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensControllerTokens(project?: string, protocolSlug?: string, underlyingTokens?: Array<string>, underlyingTokensExact?: Array<string>, primaryAddress?: Array<string>, address?: Array<string>, name?: Array<string>, symbol?: Array<string>, chainId?: number, type?: TokensControllerTokensTypeEnum, page?: number, cursor?: number, includeMetadata?: boolean, apyFrom?: number, apyTo?: number, tvlFrom?: number, tvlTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokensControllerTokens200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensControllerTokens(project, protocolSlug, underlyingTokens, underlyingTokensExact, primaryAddress, address, name, symbol, chainId, type, page, cursor, includeMetadata, apyFrom, apyTo, tvlFrom, tvlTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.tokensControllerTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns chain USD volume and total transactions
         * @param {number} chainId Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumeControllerGetVolume(chainId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumeControllerGetVolume(chainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.volumeControllerGetVolume']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns aggregators supported by the API (can be controled via disableAggregators param)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorsControllerAggregators(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.aggregatorsControllerAggregators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns networks supported by the API
         * @param {any} [name] Title of the network to search for
         * @param {any} [chainId] Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksControllerNetworks(name?: any, chainId?: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<ConnectedNetwork>> {
            return localVarFp.networksControllerNetworks(name, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns nontokenized positions and their details
         * @param {string} [project] The overarching project or platform associated with the DeFi token
         * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
         * @param {number} [chainId] Chain ID of the network of the nontokenized position
         * @param {Array<string>} [address] Ethereum addresses of the nontokenized positions
         * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of nontokenized position
         * @param {number} [page] Pagination page number. Pages are of length 1000
         * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nonTokenizedControllerTokens(project?: string, protocolSlug?: string, chainId?: number, address?: Array<string>, primaryAddress?: Array<string>, page?: number, cursor?: number, options?: RawAxiosRequestConfig): AxiosPromise<NonTokenizedControllerTokens200Response> {
            return localVarFp.nonTokenizedControllerTokens(project, protocolSlug, chainId, address, primaryAddress, page, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns price for a token
         * @param {any} address Address of the token to search for
         * @param {any} chainId Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesControllerGetPrice(address: any, chainId: any, options?: RawAxiosRequestConfig): AxiosPromise<Price> {
            return localVarFp.pricesControllerGetPrice(address, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns price for multiple tokens
         * @param {number} chainId Chain ID of the network to search for
         * @param {Array<string>} addresses Ethereum address of the token to check price for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricesControllerGetPrices(chainId: number, addresses: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Price>> {
            return localVarFp.pricesControllerGetPrices(chainId, addresses, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns projects and relevant protocols available to use
         * @param {any} [chainId] Chain ID of the network to search for
         * @param {any} [slug] slug of the project to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        protocolsControllerFindAll(chainId?: any, slug?: any, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProtocolModel>> {
            return localVarFp.protocolsControllerFindAll(chainId, slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns tokens and their details
         * @param {string} [project] The overarching project or platform associated with the DeFi token
         * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
         * @param {Array<string>} [underlyingTokens] Underlying tokens of defi token
         * @param {Array<string>} [underlyingTokensExact] Exact composition of underlying tokens of defi token
         * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of defi tokens
         * @param {Array<string>} [address] Ethereum addresses of the tokens
         * @param {Array<string>} [name] Names of the tokens
         * @param {Array<string>} [symbol] Symbols of the tokens
         * @param {number} [chainId] Chain ID of the network of the token
         * @param {TokensControllerTokensTypeEnum} [type] Type of token.       If not provided, both types will be taken into account
         * @param {number} [page] Pagination page number. Pages are of length 1000
         * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
         * @param {boolean} [includeMetadata] Whether to include token metadata (symbol, name and logos)
         * @param {number} [apyFrom] Only include tokens with APY over this value
         * @param {number} [apyTo] Only include tokens with APY below this value
         * @param {number} [tvlFrom] Only include tokens with TVL over this value
         * @param {number} [tvlTo] Only include tokens with TVL below this value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensControllerTokens(project?: string, protocolSlug?: string, underlyingTokens?: Array<string>, underlyingTokensExact?: Array<string>, primaryAddress?: Array<string>, address?: Array<string>, name?: Array<string>, symbol?: Array<string>, chainId?: number, type?: TokensControllerTokensTypeEnum, page?: number, cursor?: number, includeMetadata?: boolean, apyFrom?: number, apyTo?: number, tvlFrom?: number, tvlTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<TokensControllerTokens200Response> {
            return localVarFp.tokensControllerTokens(project, protocolSlug, underlyingTokens, underlyingTokensExact, primaryAddress, address, name, symbol, chainId, type, page, cursor, includeMetadata, apyFrom, apyTo, tvlFrom, tvlTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns chain USD volume and total transactions
         * @param {number} chainId Chain ID of the network to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumeControllerGetVolume(chainId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.volumeControllerGetVolume(chainId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * 
     * @summary Returns aggregators supported by the API (can be controled via disableAggregators param)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public aggregatorsControllerAggregators(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).aggregatorsControllerAggregators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns networks supported by the API
     * @param {any} [name] Title of the network to search for
     * @param {any} [chainId] Chain ID of the network to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public networksControllerNetworks(name?: any, chainId?: any, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).networksControllerNetworks(name, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns nontokenized positions and their details
     * @param {string} [project] The overarching project or platform associated with the DeFi token
     * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
     * @param {number} [chainId] Chain ID of the network of the nontokenized position
     * @param {Array<string>} [address] Ethereum addresses of the nontokenized positions
     * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of nontokenized position
     * @param {number} [page] Pagination page number. Pages are of length 1000
     * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public nonTokenizedControllerTokens(project?: string, protocolSlug?: string, chainId?: number, address?: Array<string>, primaryAddress?: Array<string>, page?: number, cursor?: number, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).nonTokenizedControllerTokens(project, protocolSlug, chainId, address, primaryAddress, page, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns price for a token
     * @param {any} address Address of the token to search for
     * @param {any} chainId Chain ID of the network to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public pricesControllerGetPrice(address: any, chainId: any, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).pricesControllerGetPrice(address, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns price for multiple tokens
     * @param {number} chainId Chain ID of the network to search for
     * @param {Array<string>} addresses Ethereum address of the token to check price for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public pricesControllerGetPrices(chainId: number, addresses: Array<string>, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).pricesControllerGetPrices(chainId, addresses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns projects and relevant protocols available to use
     * @param {any} [chainId] Chain ID of the network to search for
     * @param {any} [slug] slug of the project to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public protocolsControllerFindAll(chainId?: any, slug?: any, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).protocolsControllerFindAll(chainId, slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns tokens and their details
     * @param {string} [project] The overarching project or platform associated with the DeFi token
     * @param {string} [protocolSlug] The specific standard integration or version of the DeFi project
     * @param {Array<string>} [underlyingTokens] Underlying tokens of defi token
     * @param {Array<string>} [underlyingTokensExact] Exact composition of underlying tokens of defi token
     * @param {Array<string>} [primaryAddress] Ethereum addresses for contract interaction of defi tokens
     * @param {Array<string>} [address] Ethereum addresses of the tokens
     * @param {Array<string>} [name] Names of the tokens
     * @param {Array<string>} [symbol] Symbols of the tokens
     * @param {number} [chainId] Chain ID of the network of the token
     * @param {TokensControllerTokensTypeEnum} [type] Type of token.       If not provided, both types will be taken into account
     * @param {number} [page] Pagination page number. Pages are of length 1000
     * @param {number} [cursor] Cursor for pagination. Pages are of length 1000
     * @param {boolean} [includeMetadata] Whether to include token metadata (symbol, name and logos)
     * @param {number} [apyFrom] Only include tokens with APY over this value
     * @param {number} [apyTo] Only include tokens with APY below this value
     * @param {number} [tvlFrom] Only include tokens with TVL over this value
     * @param {number} [tvlTo] Only include tokens with TVL below this value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public tokensControllerTokens(project?: string, protocolSlug?: string, underlyingTokens?: Array<string>, underlyingTokensExact?: Array<string>, primaryAddress?: Array<string>, address?: Array<string>, name?: Array<string>, symbol?: Array<string>, chainId?: number, type?: TokensControllerTokensTypeEnum, page?: number, cursor?: number, includeMetadata?: boolean, apyFrom?: number, apyTo?: number, tvlFrom?: number, tvlTo?: number, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).tokensControllerTokens(project, protocolSlug, underlyingTokens, underlyingTokensExact, primaryAddress, address, name, symbol, chainId, type, page, cursor, includeMetadata, apyFrom, apyTo, tvlFrom, tvlTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns chain USD volume and total transactions
     * @param {number} chainId Chain ID of the network to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public volumeControllerGetVolume(chainId: number, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).volumeControllerGetVolume(chainId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TokensControllerTokensTypeEnum = {
    Defi: 'defi',
    Base: 'base'
} as const;
export type TokensControllerTokensTypeEnum = typeof TokensControllerTokensTypeEnum[keyof typeof TokensControllerTokensTypeEnum];


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns protocols available by project
         * @param {string} project The overarching project or platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerGetStandardsByProject: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('projectsControllerGetStandardsByProject', 'project', project)
            const localVarPath = `/api/v1/projects/{project}/protocols`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the overarching projects or platforms associated with the available projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerStandards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns protocols available by project
         * @param {string} project The overarching project or platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerGetStandardsByProject(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProtocolModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerGetStandardsByProject(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerGetStandardsByProject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the overarching projects or platforms associated with the available projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsControllerStandards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsControllerStandards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectsApi.projectsControllerStandards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns protocols available by project
         * @param {string} project The overarching project or platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerGetStandardsByProject(project: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProtocolModel>> {
            return localVarFp.projectsControllerGetStandardsByProject(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the overarching projects or platforms associated with the available projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsControllerStandards(options?: RawAxiosRequestConfig): AxiosPromise<Array<Project>> {
            return localVarFp.projectsControllerStandards(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Returns protocols available by project
     * @param {string} project The overarching project or platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerGetStandardsByProject(project: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerGetStandardsByProject(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the overarching projects or platforms associated with the available projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsControllerStandards(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsControllerStandards(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShortcutsApi - axios parameter creator
 * @export
 */
export const ShortcutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Bundle a list of actions into a single tx
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<ActionToBundle>} actionToBundle 
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {BundleControllerBundleShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleControllerBundleShortcutTransaction: async (fromAddress: string, actionToBundle: Array<ActionToBundle>, chainId?: number, referralCode?: string, routingStrategy?: BundleControllerBundleShortcutTransactionRoutingStrategyEnum, receiver?: string, spender?: string, ignoreAggregators?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('bundleControllerBundleShortcutTransaction', 'fromAddress', fromAddress)
            // verify required parameter 'actionToBundle' is not null or undefined
            assertParamExists('bundleControllerBundleShortcutTransaction', 'actionToBundle', actionToBundle)
            const localVarPath = `/api/v1/shortcuts/bundle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }

            if (routingStrategy !== undefined) {
                localVarQueryParameter['routingStrategy'] = routingStrategy;
            }

            if (receiver !== undefined) {
                localVarQueryParameter['receiver'] = receiver;
            }

            if (spender !== undefined) {
                localVarQueryParameter['spender'] = spender;
            }

            if (ignoreAggregators) {
                localVarQueryParameter['ignoreAggregators'] = ignoreAggregators;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actionToBundle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get transaction for IPOR shortcut
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {IporShortcutInput} iporShortcutInput 
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iporControllerIporShortcutTransaction: async (fromAddress: string, iporShortcutInput: IporShortcutInput, chainId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('iporControllerIporShortcutTransaction', 'fromAddress', fromAddress)
            // verify required parameter 'iporShortcutInput' is not null or undefined
            assertParamExists('iporControllerIporShortcutTransaction', 'iporShortcutInput', iporShortcutInput)
            const localVarPath = `/api/v1/shortcuts/static/ipor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iporShortcutInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Best route from a token to nontokenized position
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {string} positionOut Ethereum address of the position to receive
         * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
         * @param {string} receiver Ethereum address of the receiver of the positionOut
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
         * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
         * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nontokenizedControllerRouteNontokenizedShorcutTransaction: async (fromAddress: string, tokenIn: Array<string>, positionOut: string, amountIn: Array<string>, receiver: string, chainId?: number, routingStrategy?: NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum, referralCode?: string, slippage?: string, fee?: Array<string>, feeReceiver?: string, spender?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('nontokenizedControllerRouteNontokenizedShorcutTransaction', 'fromAddress', fromAddress)
            // verify required parameter 'tokenIn' is not null or undefined
            assertParamExists('nontokenizedControllerRouteNontokenizedShorcutTransaction', 'tokenIn', tokenIn)
            // verify required parameter 'positionOut' is not null or undefined
            assertParamExists('nontokenizedControllerRouteNontokenizedShorcutTransaction', 'positionOut', positionOut)
            // verify required parameter 'amountIn' is not null or undefined
            assertParamExists('nontokenizedControllerRouteNontokenizedShorcutTransaction', 'amountIn', amountIn)
            // verify required parameter 'receiver' is not null or undefined
            assertParamExists('nontokenizedControllerRouteNontokenizedShorcutTransaction', 'receiver', receiver)
            const localVarPath = `/api/v1/shortcuts/route/nontokenized`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (routingStrategy !== undefined) {
                localVarQueryParameter['routingStrategy'] = routingStrategy;
            }

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }

            if (tokenIn) {
                localVarQueryParameter['tokenIn'] = tokenIn;
            }

            if (positionOut !== undefined) {
                localVarQueryParameter['positionOut'] = positionOut;
            }

            if (slippage !== undefined) {
                localVarQueryParameter['slippage'] = slippage;
            }

            if (fee) {
                localVarQueryParameter['fee'] = fee;
            }

            if (feeReceiver !== undefined) {
                localVarQueryParameter['feeReceiver'] = feeReceiver;
            }

            if (amountIn) {
                localVarQueryParameter['amountIn'] = amountIn;
            }

            if (receiver !== undefined) {
                localVarQueryParameter['receiver'] = receiver;
            }

            if (spender !== undefined) {
                localVarQueryParameter['spender'] = spender;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Best route from a token to another
         * @param {RouteShortcutVariableInputs} routeShortcutVariableInputs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routerControllerPostRouteShortcutTransaction: async (routeShortcutVariableInputs: RouteShortcutVariableInputs, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routeShortcutVariableInputs' is not null or undefined
            assertParamExists('routerControllerPostRouteShortcutTransaction', 'routeShortcutVariableInputs', routeShortcutVariableInputs)
            const localVarPath = `/api/v1/shortcuts/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routeShortcutVariableInputs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Best route from a token to another
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
         * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {Array<string>} tokenOut Ethereum address of the token to swap to. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {RouterControllerRouteShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {boolean | null} [toEoa] Flag that indicates if gained tokenOut should be sent to EOA
         * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {Array<string>} [minAmountOut] Minimum amount out in wei. If specified, slippage should not be specified
         * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
         * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
         * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
         * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
         * @param {Array<string> | null} [ignoreStandards] A list of standards to be ignored from consideration
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {number} [destinationChainId] Chain ID of the network to bridge to and receive tokenOut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routerControllerRouteShortcutTransaction: async (fromAddress: string, amountIn: Array<string>, tokenIn: Array<string>, tokenOut: Array<string>, chainId?: number, routingStrategy?: RouterControllerRouteShortcutTransactionRoutingStrategyEnum, toEoa?: boolean | null, receiver?: string, spender?: string, minAmountOut?: Array<string>, slippage?: string, fee?: Array<string>, feeReceiver?: string, ignoreAggregators?: Array<string> | null, ignoreStandards?: Array<string> | null, referralCode?: string, destinationChainId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('routerControllerRouteShortcutTransaction', 'fromAddress', fromAddress)
            // verify required parameter 'amountIn' is not null or undefined
            assertParamExists('routerControllerRouteShortcutTransaction', 'amountIn', amountIn)
            // verify required parameter 'tokenIn' is not null or undefined
            assertParamExists('routerControllerRouteShortcutTransaction', 'tokenIn', tokenIn)
            // verify required parameter 'tokenOut' is not null or undefined
            assertParamExists('routerControllerRouteShortcutTransaction', 'tokenOut', tokenOut)
            const localVarPath = `/api/v1/shortcuts/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (routingStrategy !== undefined) {
                localVarQueryParameter['routingStrategy'] = routingStrategy;
            }

            if (toEoa !== undefined) {
                localVarQueryParameter['toEoa'] = toEoa;
            }

            if (receiver !== undefined) {
                localVarQueryParameter['receiver'] = receiver;
            }

            if (spender !== undefined) {
                localVarQueryParameter['spender'] = spender;
            }

            if (amountIn) {
                localVarQueryParameter['amountIn'] = amountIn;
            }

            if (minAmountOut) {
                localVarQueryParameter['minAmountOut'] = minAmountOut;
            }

            if (slippage !== undefined) {
                localVarQueryParameter['slippage'] = slippage;
            }

            if (fee) {
                localVarQueryParameter['fee'] = fee;
            }

            if (feeReceiver !== undefined) {
                localVarQueryParameter['feeReceiver'] = feeReceiver;
            }

            if (ignoreAggregators) {
                localVarQueryParameter['ignoreAggregators'] = ignoreAggregators;
            }

            if (ignoreStandards) {
                localVarQueryParameter['ignoreStandards'] = ignoreStandards;
            }

            if (referralCode !== undefined) {
                localVarQueryParameter['referralCode'] = referralCode;
            }

            if (tokenIn) {
                localVarQueryParameter['tokenIn'] = tokenIn;
            }

            if (tokenOut) {
                localVarQueryParameter['tokenOut'] = tokenOut;
            }

            if (destinationChainId !== undefined) {
                localVarQueryParameter['destinationChainId'] = destinationChainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShortcutsApi - functional programming interface
 * @export
 */
export const ShortcutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShortcutsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Bundle a list of actions into a single tx
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<ActionToBundle>} actionToBundle 
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {BundleControllerBundleShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundleControllerBundleShortcutTransaction(fromAddress: string, actionToBundle: Array<ActionToBundle>, chainId?: number, referralCode?: string, routingStrategy?: BundleControllerBundleShortcutTransactionRoutingStrategyEnum, receiver?: string, spender?: string, ignoreAggregators?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleShortcutTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundleControllerBundleShortcutTransaction(fromAddress, actionToBundle, chainId, referralCode, routingStrategy, receiver, spender, ignoreAggregators, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShortcutsApi.bundleControllerBundleShortcutTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get transaction for IPOR shortcut
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {IporShortcutInput} iporShortcutInput 
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iporControllerIporShortcutTransaction(fromAddress: string, iporShortcutInput: IporShortcutInput, chainId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IporShortcutTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iporControllerIporShortcutTransaction(fromAddress, iporShortcutInput, chainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShortcutsApi.iporControllerIporShortcutTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Best route from a token to nontokenized position
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {string} positionOut Ethereum address of the position to receive
         * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
         * @param {string} receiver Ethereum address of the receiver of the positionOut
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
         * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
         * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nontokenizedControllerRouteNontokenizedShorcutTransaction(fromAddress: string, tokenIn: Array<string>, positionOut: string, amountIn: Array<string>, receiver: string, chainId?: number, routingStrategy?: NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum, referralCode?: string, slippage?: string, fee?: Array<string>, feeReceiver?: string, spender?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteShortcutTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nontokenizedControllerRouteNontokenizedShorcutTransaction(fromAddress, tokenIn, positionOut, amountIn, receiver, chainId, routingStrategy, referralCode, slippage, fee, feeReceiver, spender, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShortcutsApi.nontokenizedControllerRouteNontokenizedShorcutTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Best route from a token to another
         * @param {RouteShortcutVariableInputs} routeShortcutVariableInputs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routerControllerPostRouteShortcutTransaction(routeShortcutVariableInputs: RouteShortcutVariableInputs, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteShortcutTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routerControllerPostRouteShortcutTransaction(routeShortcutVariableInputs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShortcutsApi.routerControllerPostRouteShortcutTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Best route from a token to another
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
         * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {Array<string>} tokenOut Ethereum address of the token to swap to. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {RouterControllerRouteShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {boolean | null} [toEoa] Flag that indicates if gained tokenOut should be sent to EOA
         * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {Array<string>} [minAmountOut] Minimum amount out in wei. If specified, slippage should not be specified
         * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
         * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
         * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
         * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
         * @param {Array<string> | null} [ignoreStandards] A list of standards to be ignored from consideration
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {number} [destinationChainId] Chain ID of the network to bridge to and receive tokenOut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routerControllerRouteShortcutTransaction(fromAddress: string, amountIn: Array<string>, tokenIn: Array<string>, tokenOut: Array<string>, chainId?: number, routingStrategy?: RouterControllerRouteShortcutTransactionRoutingStrategyEnum, toEoa?: boolean | null, receiver?: string, spender?: string, minAmountOut?: Array<string>, slippage?: string, fee?: Array<string>, feeReceiver?: string, ignoreAggregators?: Array<string> | null, ignoreStandards?: Array<string> | null, referralCode?: string, destinationChainId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteShortcutTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routerControllerRouteShortcutTransaction(fromAddress, amountIn, tokenIn, tokenOut, chainId, routingStrategy, toEoa, receiver, spender, minAmountOut, slippage, fee, feeReceiver, ignoreAggregators, ignoreStandards, referralCode, destinationChainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShortcutsApi.routerControllerRouteShortcutTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShortcutsApi - factory interface
 * @export
 */
export const ShortcutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShortcutsApiFp(configuration)
    return {
        /**
         * 
         * @summary Bundle a list of actions into a single tx
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<ActionToBundle>} actionToBundle 
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {BundleControllerBundleShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleControllerBundleShortcutTransaction(fromAddress: string, actionToBundle: Array<ActionToBundle>, chainId?: number, referralCode?: string, routingStrategy?: BundleControllerBundleShortcutTransactionRoutingStrategyEnum, receiver?: string, spender?: string, ignoreAggregators?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<BundleShortcutTransaction> {
            return localVarFp.bundleControllerBundleShortcutTransaction(fromAddress, actionToBundle, chainId, referralCode, routingStrategy, receiver, spender, ignoreAggregators, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get transaction for IPOR shortcut
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {IporShortcutInput} iporShortcutInput 
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iporControllerIporShortcutTransaction(fromAddress: string, iporShortcutInput: IporShortcutInput, chainId?: number, options?: RawAxiosRequestConfig): AxiosPromise<IporShortcutTransaction> {
            return localVarFp.iporControllerIporShortcutTransaction(fromAddress, iporShortcutInput, chainId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Best route from a token to nontokenized position
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {string} positionOut Ethereum address of the position to receive
         * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
         * @param {string} receiver Ethereum address of the receiver of the positionOut
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
         * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
         * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nontokenizedControllerRouteNontokenizedShorcutTransaction(fromAddress: string, tokenIn: Array<string>, positionOut: string, amountIn: Array<string>, receiver: string, chainId?: number, routingStrategy?: NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum, referralCode?: string, slippage?: string, fee?: Array<string>, feeReceiver?: string, spender?: string, options?: RawAxiosRequestConfig): AxiosPromise<RouteShortcutTransaction> {
            return localVarFp.nontokenizedControllerRouteNontokenizedShorcutTransaction(fromAddress, tokenIn, positionOut, amountIn, receiver, chainId, routingStrategy, referralCode, slippage, fee, feeReceiver, spender, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Best route from a token to another
         * @param {RouteShortcutVariableInputs} routeShortcutVariableInputs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routerControllerPostRouteShortcutTransaction(routeShortcutVariableInputs: RouteShortcutVariableInputs, options?: RawAxiosRequestConfig): AxiosPromise<RouteShortcutTransaction> {
            return localVarFp.routerControllerPostRouteShortcutTransaction(routeShortcutVariableInputs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Best route from a token to another
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
         * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {Array<string>} tokenOut Ethereum address of the token to swap to. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {RouterControllerRouteShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {boolean | null} [toEoa] Flag that indicates if gained tokenOut should be sent to EOA
         * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
         * @param {string} [spender] Ethereum address of the spender of the tokenIn
         * @param {Array<string>} [minAmountOut] Minimum amount out in wei. If specified, slippage should not be specified
         * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
         * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
         * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
         * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
         * @param {Array<string> | null} [ignoreStandards] A list of standards to be ignored from consideration
         * @param {string} [referralCode] Referral code that will be included in an on-chain event.
         * @param {number} [destinationChainId] Chain ID of the network to bridge to and receive tokenOut
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routerControllerRouteShortcutTransaction(fromAddress: string, amountIn: Array<string>, tokenIn: Array<string>, tokenOut: Array<string>, chainId?: number, routingStrategy?: RouterControllerRouteShortcutTransactionRoutingStrategyEnum, toEoa?: boolean | null, receiver?: string, spender?: string, minAmountOut?: Array<string>, slippage?: string, fee?: Array<string>, feeReceiver?: string, ignoreAggregators?: Array<string> | null, ignoreStandards?: Array<string> | null, referralCode?: string, destinationChainId?: number, options?: RawAxiosRequestConfig): AxiosPromise<RouteShortcutTransaction> {
            return localVarFp.routerControllerRouteShortcutTransaction(fromAddress, amountIn, tokenIn, tokenOut, chainId, routingStrategy, toEoa, receiver, spender, minAmountOut, slippage, fee, feeReceiver, ignoreAggregators, ignoreStandards, referralCode, destinationChainId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShortcutsApi - object-oriented interface
 * @export
 * @class ShortcutsApi
 * @extends {BaseAPI}
 */
export class ShortcutsApi extends BaseAPI {
    /**
     * 
     * @summary Bundle a list of actions into a single tx
     * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
     * @param {Array<ActionToBundle>} actionToBundle 
     * @param {number} [chainId] Chain ID of the network to execute the transaction on
     * @param {string} [referralCode] Referral code that will be included in an on-chain event.
     * @param {BundleControllerBundleShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
     * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
     * @param {string} [spender] Ethereum address of the spender of the tokenIn
     * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortcutsApi
     */
    public bundleControllerBundleShortcutTransaction(fromAddress: string, actionToBundle: Array<ActionToBundle>, chainId?: number, referralCode?: string, routingStrategy?: BundleControllerBundleShortcutTransactionRoutingStrategyEnum, receiver?: string, spender?: string, ignoreAggregators?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return ShortcutsApiFp(this.configuration).bundleControllerBundleShortcutTransaction(fromAddress, actionToBundle, chainId, referralCode, routingStrategy, receiver, spender, ignoreAggregators, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get transaction for IPOR shortcut
     * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
     * @param {IporShortcutInput} iporShortcutInput 
     * @param {number} [chainId] Chain ID of the network to execute the transaction on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortcutsApi
     */
    public iporControllerIporShortcutTransaction(fromAddress: string, iporShortcutInput: IporShortcutInput, chainId?: number, options?: RawAxiosRequestConfig) {
        return ShortcutsApiFp(this.configuration).iporControllerIporShortcutTransaction(fromAddress, iporShortcutInput, chainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Best route from a token to nontokenized position
     * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
     * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
     * @param {string} positionOut Ethereum address of the position to receive
     * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
     * @param {string} receiver Ethereum address of the receiver of the positionOut
     * @param {number} [chainId] Chain ID of the network to execute the transaction on
     * @param {NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
     * @param {string} [referralCode] Referral code that will be included in an on-chain event.
     * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
     * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
     * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
     * @param {string} [spender] Ethereum address of the spender of the tokenIn
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortcutsApi
     */
    public nontokenizedControllerRouteNontokenizedShorcutTransaction(fromAddress: string, tokenIn: Array<string>, positionOut: string, amountIn: Array<string>, receiver: string, chainId?: number, routingStrategy?: NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum, referralCode?: string, slippage?: string, fee?: Array<string>, feeReceiver?: string, spender?: string, options?: RawAxiosRequestConfig) {
        return ShortcutsApiFp(this.configuration).nontokenizedControllerRouteNontokenizedShorcutTransaction(fromAddress, tokenIn, positionOut, amountIn, receiver, chainId, routingStrategy, referralCode, slippage, fee, feeReceiver, spender, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Best route from a token to another
     * @param {RouteShortcutVariableInputs} routeShortcutVariableInputs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortcutsApi
     */
    public routerControllerPostRouteShortcutTransaction(routeShortcutVariableInputs: RouteShortcutVariableInputs, options?: RawAxiosRequestConfig) {
        return ShortcutsApiFp(this.configuration).routerControllerPostRouteShortcutTransaction(routeShortcutVariableInputs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Best route from a token to another
     * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
     * @param {Array<string>} amountIn Amount of tokenIn to swap in wei
     * @param {Array<string>} tokenIn Ethereum address of the token to swap from. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
     * @param {Array<string>} tokenOut Ethereum address of the token to swap to. For ETH, use 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
     * @param {number} [chainId] Chain ID of the network to execute the transaction on
     * @param {RouterControllerRouteShortcutTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
     * @param {boolean | null} [toEoa] Flag that indicates if gained tokenOut should be sent to EOA
     * @param {string} [receiver] Ethereum address of the receiver of the tokenOut
     * @param {string} [spender] Ethereum address of the spender of the tokenIn
     * @param {Array<string>} [minAmountOut] Minimum amount out in wei. If specified, slippage should not be specified
     * @param {string} [slippage] Slippage in basis points (1/10000). If specified, minAmountOut should not be specified
     * @param {Array<string>} [fee] Fee in basis points (1/10000) for each amountIn value. Must be in range 0-100. If specified, this percentage of each amountIn value will be sent to feeReceiver
     * @param {string} [feeReceiver] The Ethereum address that will receive the collected fee. Required if fee is provided
     * @param {Array<string> | null} [ignoreAggregators] A list of swap aggregators to be ignored from consideration
     * @param {Array<string> | null} [ignoreStandards] A list of standards to be ignored from consideration
     * @param {string} [referralCode] Referral code that will be included in an on-chain event.
     * @param {number} [destinationChainId] Chain ID of the network to bridge to and receive tokenOut
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShortcutsApi
     */
    public routerControllerRouteShortcutTransaction(fromAddress: string, amountIn: Array<string>, tokenIn: Array<string>, tokenOut: Array<string>, chainId?: number, routingStrategy?: RouterControllerRouteShortcutTransactionRoutingStrategyEnum, toEoa?: boolean | null, receiver?: string, spender?: string, minAmountOut?: Array<string>, slippage?: string, fee?: Array<string>, feeReceiver?: string, ignoreAggregators?: Array<string> | null, ignoreStandards?: Array<string> | null, referralCode?: string, destinationChainId?: number, options?: RawAxiosRequestConfig) {
        return ShortcutsApiFp(this.configuration).routerControllerRouteShortcutTransaction(fromAddress, amountIn, tokenIn, tokenOut, chainId, routingStrategy, toEoa, receiver, spender, minAmountOut, slippage, fee, feeReceiver, ignoreAggregators, ignoreStandards, referralCode, destinationChainId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BundleControllerBundleShortcutTransactionRoutingStrategyEnum = {
    Delegate: 'delegate',
    Router: 'router'
} as const;
export type BundleControllerBundleShortcutTransactionRoutingStrategyEnum = typeof BundleControllerBundleShortcutTransactionRoutingStrategyEnum[keyof typeof BundleControllerBundleShortcutTransactionRoutingStrategyEnum];
/**
 * @export
 */
export const NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum = {
    Delegate: 'delegate',
    DelegateLegacy: 'delegate-legacy'
} as const;
export type NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum = typeof NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum[keyof typeof NontokenizedControllerRouteNontokenizedShorcutTransactionRoutingStrategyEnum];
/**
 * @export
 */
export const RouterControllerRouteShortcutTransactionRoutingStrategyEnum = {
    Ensowallet: 'ensowallet',
    Router: 'router',
    Delegate: 'delegate',
    RouterLegacy: 'router-legacy',
    DelegateLegacy: 'delegate-legacy'
} as const;
export type RouterControllerRouteShortcutTransactionRoutingStrategyEnum = typeof RouterControllerRouteShortcutTransactionRoutingStrategyEnum[keyof typeof RouterControllerRouteShortcutTransactionRoutingStrategyEnum];


/**
 * StandardsApi - axios parameter creator
 * @export
 */
export const StandardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns actions available to use in bundle shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns actions available to use in bundle shortcuts for a given protocol
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsControllerGetActionsBySlug: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('actionsControllerGetActionsBySlug', 'slug', slug)
            const localVarPath = `/api/v1/actions/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a standard by slug
         * @param {string} slug The protocol slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standardsControllerGetProtocolBySlug: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('standardsControllerGetProtocolBySlug', 'slug', slug)
            const localVarPath = `/api/v1/standards/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns standards and methods available to use in bundle shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standardsControllerStandards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/standards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StandardsApi - functional programming interface
 * @export
 */
export const StandardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StandardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns actions available to use in bundle shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Action>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StandardsApi.actionsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns actions available to use in bundle shortcuts for a given protocol
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async actionsControllerGetActionsBySlug(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Action>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.actionsControllerGetActionsBySlug(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StandardsApi.actionsControllerGetActionsBySlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a standard by slug
         * @param {string} slug The protocol slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async standardsControllerGetProtocolBySlug(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProtocolModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.standardsControllerGetProtocolBySlug(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StandardsApi.standardsControllerGetProtocolBySlug']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns standards and methods available to use in bundle shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async standardsControllerStandards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Standard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.standardsControllerStandards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StandardsApi.standardsControllerStandards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StandardsApi - factory interface
 * @export
 */
export const StandardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StandardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns actions available to use in bundle shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsControllerFindAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<Action>> {
            return localVarFp.actionsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns actions available to use in bundle shortcuts for a given protocol
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        actionsControllerGetActionsBySlug(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Action>> {
            return localVarFp.actionsControllerGetActionsBySlug(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a standard by slug
         * @param {string} slug The protocol slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standardsControllerGetProtocolBySlug(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProtocolModel>> {
            return localVarFp.standardsControllerGetProtocolBySlug(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns standards and methods available to use in bundle shortcuts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standardsControllerStandards(options?: RawAxiosRequestConfig): AxiosPromise<Array<Standard>> {
            return localVarFp.standardsControllerStandards(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StandardsApi - object-oriented interface
 * @export
 * @class StandardsApi
 * @extends {BaseAPI}
 */
export class StandardsApi extends BaseAPI {
    /**
     * 
     * @summary Returns actions available to use in bundle shortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandardsApi
     */
    public actionsControllerFindAll(options?: RawAxiosRequestConfig) {
        return StandardsApiFp(this.configuration).actionsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns actions available to use in bundle shortcuts for a given protocol
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandardsApi
     */
    public actionsControllerGetActionsBySlug(slug: string, options?: RawAxiosRequestConfig) {
        return StandardsApiFp(this.configuration).actionsControllerGetActionsBySlug(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a standard by slug
     * @param {string} slug The protocol slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandardsApi
     */
    public standardsControllerGetProtocolBySlug(slug: string, options?: RawAxiosRequestConfig) {
        return StandardsApiFp(this.configuration).standardsControllerGetProtocolBySlug(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns standards and methods available to use in bundle shortcuts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandardsApi
     */
    public standardsControllerStandards(options?: RawAxiosRequestConfig) {
        return StandardsApiFp(this.configuration).standardsControllerStandards(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns transaction that approves your EnsoWallet to spend tokens
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {string} tokenAddress ERC20 token address of the token to approve
         * @param {string} amount Amount of tokens to approve in wei
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {WalletControllerCreateApproveTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerCreateApproveTransaction: async (fromAddress: string, tokenAddress: string, amount: string, chainId?: number, routingStrategy?: WalletControllerCreateApproveTransactionRoutingStrategyEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('walletControllerCreateApproveTransaction', 'fromAddress', fromAddress)
            // verify required parameter 'tokenAddress' is not null or undefined
            assertParamExists('walletControllerCreateApproveTransaction', 'tokenAddress', tokenAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('walletControllerCreateApproveTransaction', 'amount', amount)
            const localVarPath = `/api/v1/wallet/approve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (routingStrategy !== undefined) {
                localVarQueryParameter['routingStrategy'] = routingStrategy;
            }

            if (tokenAddress !== undefined) {
                localVarQueryParameter['tokenAddress'] = tokenAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all balances for a given wallet
         * @param {string} eoaAddress Address of the eoa with which to associate the ensoWallet for balances
         * @param {boolean} useEoa If true returns balances for the provided eoaAddress, instead of the associated ensoWallet
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerWalletBalances: async (eoaAddress: string, useEoa: boolean, chainId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eoaAddress' is not null or undefined
            assertParamExists('walletControllerWalletBalances', 'eoaAddress', eoaAddress)
            // verify required parameter 'useEoa' is not null or undefined
            assertParamExists('walletControllerWalletBalances', 'useEoa', useEoa)
            const localVarPath = `/api/v1/wallet/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chainId !== undefined) {
                localVarQueryParameter['chainId'] = chainId;
            }

            if (eoaAddress !== undefined) {
                localVarQueryParameter['eoaAddress'] = eoaAddress;
            }

            if (useEoa !== undefined) {
                localVarQueryParameter['useEoa'] = useEoa;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns transaction that approves your EnsoWallet to spend tokens
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {string} tokenAddress ERC20 token address of the token to approve
         * @param {string} amount Amount of tokens to approve in wei
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {WalletControllerCreateApproveTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerCreateApproveTransaction(fromAddress: string, tokenAddress: string, amount: string, chainId?: number, routingStrategy?: WalletControllerCreateApproveTransactionRoutingStrategyEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletApproveTransaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerCreateApproveTransaction(fromAddress, tokenAddress, amount, chainId, routingStrategy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletControllerCreateApproveTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all balances for a given wallet
         * @param {string} eoaAddress Address of the eoa with which to associate the ensoWallet for balances
         * @param {boolean} useEoa If true returns balances for the provided eoaAddress, instead of the associated ensoWallet
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletControllerWalletBalances(eoaAddress: string, useEoa: boolean, chainId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WalletBalance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletControllerWalletBalances(eoaAddress, useEoa, chainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.walletControllerWalletBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns transaction that approves your EnsoWallet to spend tokens
         * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
         * @param {string} tokenAddress ERC20 token address of the token to approve
         * @param {string} amount Amount of tokens to approve in wei
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {WalletControllerCreateApproveTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerCreateApproveTransaction(fromAddress: string, tokenAddress: string, amount: string, chainId?: number, routingStrategy?: WalletControllerCreateApproveTransactionRoutingStrategyEnum, options?: RawAxiosRequestConfig): AxiosPromise<WalletApproveTransaction> {
            return localVarFp.walletControllerCreateApproveTransaction(fromAddress, tokenAddress, amount, chainId, routingStrategy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all balances for a given wallet
         * @param {string} eoaAddress Address of the eoa with which to associate the ensoWallet for balances
         * @param {boolean} useEoa If true returns balances for the provided eoaAddress, instead of the associated ensoWallet
         * @param {number} [chainId] Chain ID of the network to execute the transaction on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletControllerWalletBalances(eoaAddress: string, useEoa: boolean, chainId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<WalletBalance>> {
            return localVarFp.walletControllerWalletBalances(eoaAddress, useEoa, chainId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * 
     * @summary Returns transaction that approves your EnsoWallet to spend tokens
     * @param {string} fromAddress Ethereum address of the wallet to send the transaction from
     * @param {string} tokenAddress ERC20 token address of the token to approve
     * @param {string} amount Amount of tokens to approve in wei
     * @param {number} [chainId] Chain ID of the network to execute the transaction on
     * @param {WalletControllerCreateApproveTransactionRoutingStrategyEnum} [routingStrategy] Routing strategy to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletControllerCreateApproveTransaction(fromAddress: string, tokenAddress: string, amount: string, chainId?: number, routingStrategy?: WalletControllerCreateApproveTransactionRoutingStrategyEnum, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletControllerCreateApproveTransaction(fromAddress, tokenAddress, amount, chainId, routingStrategy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all balances for a given wallet
     * @param {string} eoaAddress Address of the eoa with which to associate the ensoWallet for balances
     * @param {boolean} useEoa If true returns balances for the provided eoaAddress, instead of the associated ensoWallet
     * @param {number} [chainId] Chain ID of the network to execute the transaction on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public walletControllerWalletBalances(eoaAddress: string, useEoa: boolean, chainId?: number, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).walletControllerWalletBalances(eoaAddress, useEoa, chainId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const WalletControllerCreateApproveTransactionRoutingStrategyEnum = {
    Ensowallet: 'ensowallet',
    Router: 'router',
    Delegate: 'delegate',
    RouterLegacy: 'router-legacy',
    DelegateLegacy: 'delegate-legacy'
} as const;
export type WalletControllerCreateApproveTransactionRoutingStrategyEnum = typeof WalletControllerCreateApproveTransactionRoutingStrategyEnum[keyof typeof WalletControllerCreateApproveTransactionRoutingStrategyEnum];


